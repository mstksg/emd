<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE DataKinds                                #-}</span><span>
</span><span id="line-2"></span><span class="hs-pragma">{-# LANGUAGE ScopedTypeVariables                      #-}</span><span>
</span><span id="line-3"></span><span class="hs-pragma">{-# LANGUAGE TypeApplications                         #-}</span><span>
</span><span id="line-4"></span><span class="hs-pragma">{-# LANGUAGE TypeFamilies                             #-}</span><span>
</span><span id="line-5"></span><span class="hs-pragma">{-# LANGUAGE TypeOperators                            #-}</span><span>
</span><span id="line-6"></span><span class="hs-pragma">{-# OPTIONS_GHC -fplugin GHC.TypeLits.KnownNat.Solver #-}</span><span>
</span><span id="line-7"></span><span class="hs-pragma">{-# OPTIONS_GHC -fplugin GHC.TypeLits.Normalise       #-}</span><span>
</span><span id="line-8"></span><span>
</span><span id="line-9"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Numeric.EMD.Internal.Tridiagonal</span><span> </span><span class="hs-special">(</span><span>
</span><span id="line-10"></span><span>    </span><span class="annot"><a href="Numeric.EMD.Internal.Tridiagonal.html#solveTridiagonal"><span class="hs-identifier">solveTridiagonal</span></a></span><span>
</span><span id="line-11"></span><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-12"></span><span>
</span><span id="line-13"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Control.Applicative.Backwards</span></span><span>
</span><span id="line-14"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Control.Monad</span></span><span>
</span><span id="line-15"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Control.Monad.ST</span></span><span>
</span><span id="line-16"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Control.Monad.Trans.Class</span></span><span>
</span><span id="line-17"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Control.Monad.Trans.Maybe</span></span><span>
</span><span id="line-18"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Finite</span></span><span>
</span><span id="line-19"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Foldable</span></span><span>
</span><span id="line-20"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">GHC.TypeNats</span></span><span>
</span><span id="line-21"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.Vector.Generic</span></span><span>               </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">VG</span></span><span>
</span><span id="line-22"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.Vector.Generic.Mutable.Sized</span></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">SMVG</span></span><span>
</span><span id="line-23"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.Vector.Generic.Sized</span></span><span>         </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">SVG</span></span><span>
</span><span id="line-24"></span><span>
</span><span id="line-25"></span><span class="hs-comment">-- | &lt;https://en.wikipedia.org/wiki/Tridiagonal_matrix_algorithm&gt;</span><span>
</span><span id="line-26"></span><span class="hs-comment">--</span><span>
</span><span id="line-27"></span><span class="hs-comment">-- Will return 'Nothing' if the matrix is not invertible.  This will happen</span><span>
</span><span id="line-28"></span><span class="hs-comment">-- if:</span><span>
</span><span id="line-29"></span><span class="hs-comment">--</span><span>
</span><span id="line-30"></span><span class="hs-comment">-- 1. The first item in the main diagonal is zero</span><span>
</span><span id="line-31"></span><span class="hs-comment">-- 2. There is any i such that b_{i + 1} = a_i * c_i.  That is, an item in</span><span>
</span><span id="line-32"></span><span class="hs-comment">-- the main diagonal is equal to the product of the off-diagonal elements</span><span>
</span><span id="line-33"></span><span class="hs-comment">-- a row above it</span><span>
</span><span id="line-34"></span><span class="hs-comment">-- 3. Another mystery condition!</span><span>
</span><span id="line-35"></span><span class="annot"><a href="Numeric.EMD.Internal.Tridiagonal.html#solveTridiagonal"><span class="hs-identifier hs-type">solveTridiagonal</span></a></span><span>
</span><span id="line-36"></span><span>    </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621679165882"><span class="annot"><a href="#local-6989586621679165882"><span class="hs-identifier hs-type">v</span></a></span></span><span> </span><span id="local-6989586621679165881"><span class="annot"><a href="#local-6989586621679165881"><span class="hs-identifier hs-type">n</span></a></span></span><span> </span><span id="local-6989586621679165880"><span class="annot"><a href="#local-6989586621679165880"><span class="hs-identifier hs-type">a</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">VG.Vector</span></span><span> </span><span class="annot"><a href="#local-6989586621679165882"><span class="hs-identifier hs-type">v</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679165880"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">KnownNat</span></span><span> </span><span class="annot"><a href="#local-6989586621679165881"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Fractional</span></span><span> </span><span class="annot"><a href="#local-6989586621679165880"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="annot"><a href="#local-6989586621679165880"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-37"></span><span>    </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">SVG.Vector</span></span><span> </span><span class="annot"><a href="#local-6989586621679165882"><span class="hs-identifier hs-type">v</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679165881"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">+</span></span><span> </span><span class="annot"><span class="hs-number">1</span></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679165880"><span class="hs-identifier hs-type">a</span></a></span><span>           </span><span class="hs-comment">-- ^ a: Bottom diagonal of M</span><span>
</span><span id="line-38"></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">SVG.Vector</span></span><span> </span><span class="annot"><a href="#local-6989586621679165882"><span class="hs-identifier hs-type">v</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679165881"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">+</span></span><span> </span><span class="annot"><span class="hs-number">2</span></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679165880"><span class="hs-identifier hs-type">a</span></a></span><span>           </span><span class="hs-comment">-- ^ b: Main diagonal of M</span><span>
</span><span id="line-39"></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">SVG.Vector</span></span><span> </span><span class="annot"><a href="#local-6989586621679165882"><span class="hs-identifier hs-type">v</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679165881"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">+</span></span><span> </span><span class="annot"><span class="hs-number">1</span></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679165880"><span class="hs-identifier hs-type">a</span></a></span><span>           </span><span class="hs-comment">-- ^ c: Upper diagonal of M</span><span>
</span><span id="line-40"></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">SVG.Vector</span></span><span> </span><span class="annot"><a href="#local-6989586621679165882"><span class="hs-identifier hs-type">v</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679165881"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">+</span></span><span> </span><span class="annot"><span class="hs-number">2</span></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679165880"><span class="hs-identifier hs-type">a</span></a></span><span>           </span><span class="hs-comment">-- ^ y</span><span>
</span><span id="line-41"></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">SVG.Vector</span></span><span> </span><span class="annot"><a href="#local-6989586621679165882"><span class="hs-identifier hs-type">v</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679165881"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">+</span></span><span> </span><span class="annot"><span class="hs-number">2</span></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679165880"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span>   </span><span class="hs-comment">-- ^ x such that M x = y</span><span>
</span><span id="line-42"></span><span id="solveTridiagonal"><span class="annot"><span class="annottext">solveTridiagonal :: Vector v (n + 1) a
-&gt; Vector v (n + 2) a
-&gt; Vector v (n + 1) a
-&gt; Vector v (n + 2) a
-&gt; Maybe (Vector v (n + 2) a)
</span><a href="Numeric.EMD.Internal.Tridiagonal.html#solveTridiagonal"><span class="hs-identifier hs-var hs-var">solveTridiagonal</span></a></span></span><span> </span><span id="local-6989586621679165879"><span class="annot"><span class="annottext">as :: Vector v (n + 1) a
</span><a href="#local-6989586621679165879"><span class="hs-keyword hs-var">as</span></a></span></span><span> </span><span id="local-6989586621679165878"><span class="annot"><span class="annottext">bs :: Vector v (n + 2) a
</span><a href="#local-6989586621679165878"><span class="hs-identifier hs-var">bs</span></a></span></span><span> </span><span id="local-6989586621679165877"><span class="annot"><span class="annottext">cs :: Vector v (n + 1) a
</span><a href="#local-6989586621679165877"><span class="hs-identifier hs-var">cs</span></a></span></span><span> </span><span id="local-6989586621679165876"><span class="annot"><span class="annottext">ds :: Vector v (n + 2) a
</span><a href="#local-6989586621679165876"><span class="hs-identifier hs-var">ds</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall s. ST s (Maybe (Vector v (n + 2) a)))
-&gt; Maybe (Vector v (n + 2) a)
forall a. (forall s. ST s a) -&gt; a
</span><span class="hs-identifier hs-var">runST</span></span><span> </span><span class="annot"><span class="annottext">((forall s. ST s (Maybe (Vector v (n + 2) a)))
 -&gt; Maybe (Vector v (n + 2) a))
-&gt; (forall s. ST s (Maybe (Vector v (n + 2) a)))
-&gt; Maybe (Vector v (n + 2) a)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">MaybeT (ST s) (Vector v ((n + 1) + 1) a)
-&gt; ST s (Maybe (Vector v (n + 2) a))
forall (m :: * -&gt; *) a. MaybeT m a -&gt; m (Maybe a)
</span><span class="hs-identifier hs-var hs-var">runMaybeT</span></span><span> </span><span class="annot"><span class="annottext">(MaybeT (ST s) (Vector v ((n + 1) + 1) a)
 -&gt; ST s (Maybe (Vector v (n + 2) a)))
-&gt; MaybeT (ST s) (Vector v ((n + 1) + 1) a)
-&gt; ST s (Maybe (Vector v (n + 2) a))
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-43"></span><span>    </span><span class="annot"><span class="annottext">Bool -&gt; MaybeT (ST s) ()
forall (f :: * -&gt; *). Alternative f =&gt; Bool -&gt; f ()
</span><span class="hs-identifier hs-var">guard</span></span><span> </span><span class="annot"><span class="annottext">(Bool -&gt; MaybeT (ST s) ()) -&gt; Bool -&gt; MaybeT (ST s) ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Vector v (1 + (1 + n)) a -&gt; a
forall (v :: * -&gt; *) (n :: Nat) a.
Vector v a =&gt;
Vector v (1 + n) a -&gt; a
</span><span class="hs-identifier hs-var">SVG.head</span></span><span> </span><span class="annot"><span class="annottext">Vector v (n + 2) a
Vector v (1 + (1 + n)) a
</span><a href="#local-6989586621679165878"><span class="hs-identifier hs-var">bs</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; a -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">/=</span></span><span> </span><span class="annot"><span class="hs-number">0</span></span><span>
</span><span id="line-44"></span><span>    </span><span id="local-6989586621679165871"><span class="annot"><span class="annottext">Vector v (n + 1) a
</span><a href="#local-6989586621679165871"><span class="hs-identifier hs-var">cs'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">MaybeT (ST s) (Vector v (n + 1) a)
forall s. MaybeT (ST s) (Vector v (n + 1) a)
</span><a href="#local-6989586621679165870"><span class="hs-identifier hs-var">makeCs</span></a></span><span>
</span><span id="line-45"></span><span>    </span><span id="local-6989586621679165869"><span class="annot"><span class="annottext">MVector (Mutable v) ((n + 1) + 1) s a
</span><a href="#local-6989586621679165869"><span class="hs-identifier hs-var">mxs</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">ST s (MVector (Mutable v) ((n + 1) + 1) s a)
-&gt; MaybeT (ST s) (MVector (Mutable v) ((n + 1) + 1) s a)
forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
(MonadTrans t, Monad m) =&gt;
m a -&gt; t m a
</span><span class="hs-identifier hs-var">lift</span></span><span> </span><span class="annot"><span class="annottext">(ST s (MVector (Mutable v) ((n + 1) + 1) s a)
 -&gt; MaybeT (ST s) (MVector (Mutable v) ((n + 1) + 1) s a))
-&gt; ST s (MVector (Mutable v) ((n + 1) + 1) s a)
-&gt; MaybeT (ST s) (MVector (Mutable v) ((n + 1) + 1) s a)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Vector v ((n + 1) + 1) a
-&gt; ST s (MVector (Mutable v) ((n + 1) + 1) (PrimState (ST s)) a)
forall (m :: * -&gt; *) (v :: * -&gt; *) a (n :: Nat).
(PrimMonad m, Vector v a) =&gt;
Vector v n a -&gt; m (MVector (Mutable v) n (PrimState m) a)
</span><span class="hs-identifier hs-var">SVG.thaw</span></span><span> </span><span class="annot"><span class="annottext">Vector v (n + 2) a
Vector v ((n + 1) + 1) a
</span><a href="#local-6989586621679165876"><span class="hs-identifier hs-var">ds</span></a></span><span>
</span><span id="line-46"></span><span>    </span><span class="annot"><span class="annottext">Vector v (n + 1) a
-&gt; MVector (Mutable v) (n + 2) s a -&gt; MaybeT (ST s) ()
forall s.
Vector v (n + 1) a
-&gt; MVector (Mutable v) (n + 2) s a -&gt; MaybeT (ST s) ()
</span><a href="#local-6989586621679165866"><span class="hs-identifier hs-var">makeDs</span></a></span><span> </span><span class="annot"><span class="annottext">Vector v (n + 1) a
</span><a href="#local-6989586621679165871"><span class="hs-identifier hs-var">cs'</span></a></span><span> </span><span class="annot"><span class="annottext">MVector (Mutable v) (n + 2) s a
MVector (Mutable v) ((n + 1) + 1) s a
</span><a href="#local-6989586621679165869"><span class="hs-identifier hs-var">mxs</span></a></span><span>
</span><span id="line-47"></span><span>    </span><span class="annot"><span class="annottext">Backwards (MaybeT (ST s)) () -&gt; MaybeT (ST s) ()
forall k (f :: k -&gt; *) (a :: k). Backwards f a -&gt; f a
</span><span class="hs-identifier hs-var hs-var">forwards</span></span><span> </span><span class="annot"><span class="annottext">(Backwards (MaybeT (ST s)) () -&gt; MaybeT (ST s) ())
-&gt; (((Finite (n + 1), Finite ((n + 1) + 1))
     -&gt; Backwards (MaybeT (ST s)) ())
    -&gt; Backwards (MaybeT (ST s)) ())
-&gt; ((Finite (n + 1), Finite ((n + 1) + 1))
    -&gt; Backwards (MaybeT (ST s)) ())
-&gt; MaybeT (ST s) ()
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">[(Finite (n + 1), Finite ((n + 1) + 1))]
-&gt; ((Finite (n + 1), Finite ((n + 1) + 1))
    -&gt; Backwards (MaybeT (ST s)) ())
-&gt; Backwards (MaybeT (ST s)) ()
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Foldable t, Applicative f) =&gt;
t a -&gt; (a -&gt; f b) -&gt; f ()
</span><span class="hs-identifier hs-var">for_</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">KnownNat (n + 1) =&gt; [(Finite (n + 1), Finite ((n + 1) + 1))]
forall (n :: Nat). KnownNat n =&gt; [(Finite n, Finite (n + 1))]
</span><a href="Numeric.EMD.Internal.Tridiagonal.html#consecFinites"><span class="hs-identifier hs-var">consecFinites</span></a></span><span> </span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679165881"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">+</span></span><span> </span><span class="annot"><span class="hs-number">1</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(((Finite (n + 1), Finite ((n + 1) + 1))
  -&gt; Backwards (MaybeT (ST s)) ())
 -&gt; MaybeT (ST s) ())
-&gt; ((Finite (n + 1), Finite ((n + 1) + 1))
    -&gt; Backwards (MaybeT (ST s)) ())
-&gt; MaybeT (ST s) ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-special">(</span><span id="local-6989586621679165861"><span class="annot"><span class="annottext">i0 :: Finite (n + 1)
</span><a href="#local-6989586621679165861"><span class="hs-identifier hs-var">i0</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679165860"><span class="annot"><span class="annottext">i1 :: Finite ((n + 1) + 1)
</span><a href="#local-6989586621679165860"><span class="hs-identifier hs-var">i1</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">MaybeT (ST s) () -&gt; Backwards (MaybeT (ST s)) ()
forall k (f :: k -&gt; *) (a :: k). f a -&gt; Backwards f a
</span><span class="hs-identifier hs-var">Backwards</span></span><span> </span><span class="annot"><span class="annottext">(MaybeT (ST s) () -&gt; Backwards (MaybeT (ST s)) ())
-&gt; MaybeT (ST s) () -&gt; Backwards (MaybeT (ST s)) ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-48"></span><span>      </span><span id="local-6989586621679165858"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679165858"><span class="hs-identifier hs-var">x1</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">ST s a -&gt; MaybeT (ST s) a
forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
(MonadTrans t, Monad m) =&gt;
m a -&gt; t m a
</span><span class="hs-identifier hs-var">lift</span></span><span> </span><span class="annot"><span class="annottext">(ST s a -&gt; MaybeT (ST s) a) -&gt; ST s a -&gt; MaybeT (ST s) a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">MVector (Mutable v) ((n + 1) + 1) (PrimState (ST s)) a
-&gt; Finite ((n + 1) + 1) -&gt; ST s a
forall (v :: * -&gt; * -&gt; *) (n :: Nat) (m :: * -&gt; *) a.
(PrimMonad m, MVector v a) =&gt;
MVector v n (PrimState m) a -&gt; Finite n -&gt; m a
</span><span class="hs-identifier hs-var">SMVG.read</span></span><span> </span><span class="annot"><span class="annottext">MVector (Mutable v) ((n + 1) + 1) s a
MVector (Mutable v) ((n + 1) + 1) (PrimState (ST s)) a
</span><a href="#local-6989586621679165869"><span class="hs-identifier hs-var">mxs</span></a></span><span> </span><span class="annot"><span class="annottext">Finite ((n + 1) + 1)
</span><a href="#local-6989586621679165860"><span class="hs-identifier hs-var">i1</span></a></span><span>
</span><span id="line-49"></span><span>      </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679165856"><span class="annot"><span class="annottext">sbr :: a
</span><a href="#local-6989586621679165856"><span class="hs-identifier hs-var hs-var">sbr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Vector v (n + 1) a
</span><a href="#local-6989586621679165871"><span class="hs-identifier hs-var">cs'</span></a></span><span> </span><span class="annot"><span class="annottext">Vector v (n + 1) a -&gt; Finite (n + 1) -&gt; a
forall (v :: * -&gt; *) (n :: Nat) a.
Vector v a =&gt;
Vector v n a -&gt; Finite n -&gt; a
</span><span class="hs-operator hs-var">`SVG.index`</span></span><span> </span><span class="annot"><span class="annottext">Finite (n + 1)
</span><a href="#local-6989586621679165861"><span class="hs-identifier hs-var">i0</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; a -&gt; a
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">*</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679165858"><span class="hs-identifier hs-var">x1</span></a></span><span>
</span><span id="line-50"></span><span>      </span><span class="annot"><span class="annottext">ST s () -&gt; MaybeT (ST s) ()
forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
(MonadTrans t, Monad m) =&gt;
m a -&gt; t m a
</span><span class="hs-identifier hs-var">lift</span></span><span> </span><span class="annot"><span class="annottext">(ST s () -&gt; MaybeT (ST s) ()) -&gt; ST s () -&gt; MaybeT (ST s) ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">MVector (Mutable v) ((n + 1) + 1) (PrimState (ST s)) a
-&gt; (a -&gt; a) -&gt; Finite ((n + 1) + 1) -&gt; ST s ()
forall (v :: * -&gt; * -&gt; *) (n :: Nat) (m :: * -&gt; *) a.
(PrimMonad m, MVector v a) =&gt;
MVector v n (PrimState m) a -&gt; (a -&gt; a) -&gt; Finite n -&gt; m ()
</span><span class="hs-identifier hs-var">SMVG.modify</span></span><span> </span><span class="annot"><span class="annottext">MVector (Mutable v) ((n + 1) + 1) s a
MVector (Mutable v) ((n + 1) + 1) (PrimState (ST s)) a
</span><a href="#local-6989586621679165869"><span class="hs-identifier hs-var">mxs</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; a -&gt; a
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-identifier hs-var">subtract</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679165856"><span class="hs-identifier hs-var">sbr</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Finite (n + 1) -&gt; Finite ((n + 1) + 1)
forall (n :: Nat). Finite n -&gt; Finite (n + 1)
</span><span class="hs-identifier hs-var">weaken</span></span><span> </span><span class="annot"><span class="annottext">Finite (n + 1)
</span><a href="#local-6989586621679165861"><span class="hs-identifier hs-var">i0</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-51"></span><span>    </span><span class="annot"><span class="annottext">ST s (Vector v ((n + 1) + 1) a)
-&gt; MaybeT (ST s) (Vector v ((n + 1) + 1) a)
forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
(MonadTrans t, Monad m) =&gt;
m a -&gt; t m a
</span><span class="hs-identifier hs-var">lift</span></span><span> </span><span class="annot"><span class="annottext">(ST s (Vector v ((n + 1) + 1) a)
 -&gt; MaybeT (ST s) (Vector v ((n + 1) + 1) a))
-&gt; ST s (Vector v ((n + 1) + 1) a)
-&gt; MaybeT (ST s) (Vector v ((n + 1) + 1) a)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">MVector (Mutable v) ((n + 1) + 1) (PrimState (ST s)) a
-&gt; ST s (Vector v ((n + 1) + 1) a)
forall (m :: * -&gt; *) (v :: * -&gt; *) a (n :: Nat).
(PrimMonad m, Vector v a) =&gt;
MVector (Mutable v) n (PrimState m) a -&gt; m (Vector v n a)
</span><span class="hs-identifier hs-var">SVG.freeze</span></span><span> </span><span class="annot"><span class="annottext">MVector (Mutable v) ((n + 1) + 1) s a
MVector (Mutable v) ((n + 1) + 1) (PrimState (ST s)) a
</span><a href="#local-6989586621679165869"><span class="hs-identifier hs-var">mxs</span></a></span><span>
</span><span id="line-52"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-53"></span><span>    </span><span id="local-6989586621679165940"><span class="annot"><a href="#local-6989586621679165870"><span class="hs-identifier hs-type">makeCs</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">MaybeT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ST</span></span><span> </span><span class="annot"><a href="#local-6989586621679165940"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">SVG.Vector</span></span><span> </span><span class="annot"><a href="#local-6989586621679165882"><span class="hs-identifier hs-type">v</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679165881"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">+</span></span><span> </span><span class="annot"><span class="hs-number">1</span></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679165880"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-54"></span><span>    </span><span id="local-6989586621679165870"><span class="annot"><span class="annottext">makeCs :: MaybeT (ST s) (Vector v (n + 1) a)
</span><a href="#local-6989586621679165870"><span class="hs-identifier hs-var hs-var">makeCs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-55"></span><span>      </span><span id="local-6989586621679165849"><span class="annot"><span class="annottext">MVector (Mutable v) (n + 1) s a
</span><a href="#local-6989586621679165849"><span class="hs-identifier hs-var">mcs</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">ST s (MVector (Mutable v) (n + 1) s a)
-&gt; MaybeT (ST s) (MVector (Mutable v) (n + 1) s a)
forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
(MonadTrans t, Monad m) =&gt;
m a -&gt; t m a
</span><span class="hs-identifier hs-var">lift</span></span><span> </span><span class="annot"><span class="annottext">(ST s (MVector (Mutable v) (n + 1) s a)
 -&gt; MaybeT (ST s) (MVector (Mutable v) (n + 1) s a))
-&gt; ST s (MVector (Mutable v) (n + 1) s a)
-&gt; MaybeT (ST s) (MVector (Mutable v) (n + 1) s a)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Vector v (n + 1) a
-&gt; ST s (MVector (Mutable v) (n + 1) (PrimState (ST s)) a)
forall (m :: * -&gt; *) (v :: * -&gt; *) a (n :: Nat).
(PrimMonad m, Vector v a) =&gt;
Vector v n a -&gt; m (MVector (Mutable v) n (PrimState m) a)
</span><span class="hs-identifier hs-var">SVG.thaw</span></span><span> </span><span class="annot"><span class="annottext">Vector v (n + 1) a
</span><a href="#local-6989586621679165877"><span class="hs-identifier hs-var">cs</span></a></span><span>
</span><span id="line-56"></span><span>      </span><span class="annot"><span class="annottext">ST s () -&gt; MaybeT (ST s) ()
forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
(MonadTrans t, Monad m) =&gt;
m a -&gt; t m a
</span><span class="hs-identifier hs-var">lift</span></span><span> </span><span class="annot"><span class="annottext">(ST s () -&gt; MaybeT (ST s) ()) -&gt; ST s () -&gt; MaybeT (ST s) ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">MVector (Mutable v) (n + 1) (PrimState (ST s)) a
-&gt; (a -&gt; a) -&gt; Finite (n + 1) -&gt; ST s ()
forall (v :: * -&gt; * -&gt; *) (n :: Nat) (m :: * -&gt; *) a.
(PrimMonad m, MVector v a) =&gt;
MVector v n (PrimState m) a -&gt; (a -&gt; a) -&gt; Finite n -&gt; m ()
</span><span class="hs-identifier hs-var">SMVG.modify</span></span><span> </span><span class="annot"><span class="annottext">MVector (Mutable v) (n + 1) s a
MVector (Mutable v) (n + 1) (PrimState (ST s)) a
</span><a href="#local-6989586621679165849"><span class="hs-identifier hs-var">mcs</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; a -&gt; a
forall a. Fractional a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">/</span></span><span> </span><span class="annot"><span class="annottext">Vector v (1 + (1 + n)) a -&gt; a
forall (v :: * -&gt; *) (n :: Nat) a.
Vector v a =&gt;
Vector v (1 + n) a -&gt; a
</span><span class="hs-identifier hs-var">SVG.head</span></span><span> </span><span class="annot"><span class="annottext">Vector v (n + 2) a
Vector v (1 + (1 + n)) a
</span><a href="#local-6989586621679165878"><span class="hs-identifier hs-var">bs</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Finite (n + 1)
forall a. Bounded a =&gt; a
</span><span class="hs-identifier hs-var">minBound</span></span><span>
</span><span id="line-57"></span><span>      </span><span class="annot"><span class="annottext">[(Finite n, Finite (n + 1))]
-&gt; ((Finite n, Finite (n + 1)) -&gt; MaybeT (ST s) ())
-&gt; MaybeT (ST s) ()
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Foldable t, Applicative f) =&gt;
t a -&gt; (a -&gt; f b) -&gt; f ()
</span><span class="hs-identifier hs-var">for_</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">KnownNat n =&gt; [(Finite n, Finite (n + 1))]
forall (n :: Nat). KnownNat n =&gt; [(Finite n, Finite (n + 1))]
</span><a href="Numeric.EMD.Internal.Tridiagonal.html#consecFinites"><span class="hs-identifier hs-var">consecFinites</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621679165881"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(((Finite n, Finite (n + 1)) -&gt; MaybeT (ST s) ())
 -&gt; MaybeT (ST s) ())
-&gt; ((Finite n, Finite (n + 1)) -&gt; MaybeT (ST s) ())
-&gt; MaybeT (ST s) ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-special">(</span><span id="local-6989586621679165846"><span class="annot"><span class="annottext">i0 :: Finite n
</span><a href="#local-6989586621679165846"><span class="hs-identifier hs-var">i0</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679165845"><span class="annot"><span class="annottext">i1 :: Finite (n + 1)
</span><a href="#local-6989586621679165845"><span class="hs-identifier hs-var">i1</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-58"></span><span>        </span><span id="local-6989586621679165844"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679165844"><span class="hs-identifier hs-var">c0</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">ST s a -&gt; MaybeT (ST s) a
forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
(MonadTrans t, Monad m) =&gt;
m a -&gt; t m a
</span><span class="hs-identifier hs-var">lift</span></span><span> </span><span class="annot"><span class="annottext">(ST s a -&gt; MaybeT (ST s) a) -&gt; ST s a -&gt; MaybeT (ST s) a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">MVector (Mutable v) (n + 1) (PrimState (ST s)) a
-&gt; Finite (n + 1) -&gt; ST s a
forall (v :: * -&gt; * -&gt; *) (n :: Nat) (m :: * -&gt; *) a.
(PrimMonad m, MVector v a) =&gt;
MVector v n (PrimState m) a -&gt; Finite n -&gt; m a
</span><span class="hs-identifier hs-var">SMVG.read</span></span><span> </span><span class="annot"><span class="annottext">MVector (Mutable v) (n + 1) s a
MVector (Mutable v) (n + 1) (PrimState (ST s)) a
</span><a href="#local-6989586621679165849"><span class="hs-identifier hs-var">mcs</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Finite n -&gt; Finite (n + 1)
forall (n :: Nat). Finite n -&gt; Finite (n + 1)
</span><span class="hs-identifier hs-var">weaken</span></span><span> </span><span class="annot"><span class="annottext">Finite n
</span><a href="#local-6989586621679165846"><span class="hs-identifier hs-var">i0</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-59"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679165843"><span class="annot"><span class="annottext">dvr :: a
</span><a href="#local-6989586621679165843"><span class="hs-identifier hs-var hs-var">dvr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Vector v (n + 2) a
Vector v ((n + 1) + 1) a
</span><a href="#local-6989586621679165878"><span class="hs-identifier hs-var">bs</span></a></span><span> </span><span class="annot"><span class="annottext">Vector v ((n + 1) + 1) a -&gt; Finite ((n + 1) + 1) -&gt; a
forall (v :: * -&gt; *) (n :: Nat) a.
Vector v a =&gt;
Vector v n a -&gt; Finite n -&gt; a
</span><span class="hs-operator hs-var">`SVG.index`</span></span><span> </span><span class="annot"><span class="annottext">Finite (n + 1) -&gt; Finite ((n + 1) + 1)
forall (n :: Nat). Finite n -&gt; Finite (n + 1)
</span><span class="hs-identifier hs-var">weaken</span></span><span> </span><span class="annot"><span class="annottext">Finite (n + 1)
</span><a href="#local-6989586621679165845"><span class="hs-identifier hs-var">i1</span></a></span><span>
</span><span id="line-60"></span><span>                </span><span class="annot"><span class="annottext">a -&gt; a -&gt; a
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">Vector v (n + 1) a
</span><a href="#local-6989586621679165879"><span class="hs-keyword hs-var">as</span></a></span><span> </span><span class="annot"><span class="annottext">Vector v (n + 1) a -&gt; Finite (n + 1) -&gt; a
forall (v :: * -&gt; *) (n :: Nat) a.
Vector v a =&gt;
Vector v n a -&gt; Finite n -&gt; a
</span><span class="hs-operator hs-var">`SVG.index`</span></span><span> </span><span class="annot"><span class="annottext">Finite n -&gt; Finite (n + 1)
forall (n :: Nat). Finite n -&gt; Finite (n + 1)
</span><span class="hs-identifier hs-var">weaken</span></span><span> </span><span class="annot"><span class="annottext">Finite n
</span><a href="#local-6989586621679165846"><span class="hs-identifier hs-var">i0</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; a -&gt; a
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">*</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679165844"><span class="hs-identifier hs-var">c0</span></a></span><span>
</span><span id="line-61"></span><span>        </span><span class="annot"><span class="annottext">Bool -&gt; MaybeT (ST s) ()
forall (f :: * -&gt; *). Alternative f =&gt; Bool -&gt; f ()
</span><span class="hs-identifier hs-var">guard</span></span><span> </span><span class="annot"><span class="annottext">(Bool -&gt; MaybeT (ST s) ()) -&gt; Bool -&gt; MaybeT (ST s) ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679165843"><span class="hs-identifier hs-var">dvr</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; a -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">/=</span></span><span> </span><span class="annot"><span class="hs-number">0</span></span><span>
</span><span id="line-62"></span><span>        </span><span class="annot"><span class="annottext">ST s () -&gt; MaybeT (ST s) ()
forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
(MonadTrans t, Monad m) =&gt;
m a -&gt; t m a
</span><span class="hs-identifier hs-var">lift</span></span><span> </span><span class="annot"><span class="annottext">(ST s () -&gt; MaybeT (ST s) ()) -&gt; ST s () -&gt; MaybeT (ST s) ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">MVector (Mutable v) (n + 1) (PrimState (ST s)) a
-&gt; (a -&gt; a) -&gt; Finite (n + 1) -&gt; ST s ()
forall (v :: * -&gt; * -&gt; *) (n :: Nat) (m :: * -&gt; *) a.
(PrimMonad m, MVector v a) =&gt;
MVector v n (PrimState m) a -&gt; (a -&gt; a) -&gt; Finite n -&gt; m ()
</span><span class="hs-identifier hs-var">SMVG.modify</span></span><span> </span><span class="annot"><span class="annottext">MVector (Mutable v) (n + 1) s a
MVector (Mutable v) (n + 1) (PrimState (ST s)) a
</span><a href="#local-6989586621679165849"><span class="hs-identifier hs-var">mcs</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; a -&gt; a
forall a. Fractional a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">/</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679165843"><span class="hs-identifier hs-var">dvr</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Finite (n + 1)
</span><a href="#local-6989586621679165845"><span class="hs-identifier hs-var">i1</span></a></span><span>
</span><span id="line-63"></span><span>      </span><span class="annot"><span class="annottext">ST s (Vector v (n + 1) a) -&gt; MaybeT (ST s) (Vector v (n + 1) a)
forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
(MonadTrans t, Monad m) =&gt;
m a -&gt; t m a
</span><span class="hs-identifier hs-var">lift</span></span><span> </span><span class="annot"><span class="annottext">(ST s (Vector v (n + 1) a) -&gt; MaybeT (ST s) (Vector v (n + 1) a))
-&gt; ST s (Vector v (n + 1) a) -&gt; MaybeT (ST s) (Vector v (n + 1) a)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">MVector (Mutable v) (n + 1) (PrimState (ST s)) a
-&gt; ST s (Vector v (n + 1) a)
forall (m :: * -&gt; *) (v :: * -&gt; *) a (n :: Nat).
(PrimMonad m, Vector v a) =&gt;
MVector (Mutable v) n (PrimState m) a -&gt; m (Vector v n a)
</span><span class="hs-identifier hs-var">SVG.freeze</span></span><span> </span><span class="annot"><span class="annottext">MVector (Mutable v) (n + 1) s a
MVector (Mutable v) (n + 1) (PrimState (ST s)) a
</span><a href="#local-6989586621679165849"><span class="hs-identifier hs-var">mcs</span></a></span><span>
</span><span id="line-64"></span><span>    </span><span id="local-6989586621679165927"><span class="annot"><a href="#local-6989586621679165866"><span class="hs-identifier hs-type">makeDs</span></a></span><span>
</span><span id="line-65"></span><span>        </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">SVG.Vector</span></span><span> </span><span class="annot"><a href="#local-6989586621679165882"><span class="hs-identifier hs-type">v</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679165881"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">+</span></span><span> </span><span class="annot"><span class="hs-number">1</span></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679165880"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-66"></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">SVG.MVector</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">VG.Mutable</span></span><span> </span><span class="annot"><a href="#local-6989586621679165882"><span class="hs-identifier hs-type">v</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679165881"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">+</span></span><span> </span><span class="annot"><span class="hs-number">2</span></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679165927"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679165880"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-67"></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">MaybeT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ST</span></span><span> </span><span class="annot"><a href="#local-6989586621679165927"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span><span>
</span><span id="line-68"></span><span>    </span><span id="local-6989586621679165866"><span class="annot"><span class="annottext">makeDs :: Vector v (n + 1) a
-&gt; MVector (Mutable v) (n + 2) s a -&gt; MaybeT (ST s) ()
</span><a href="#local-6989586621679165866"><span class="hs-identifier hs-var hs-var">makeDs</span></a></span></span><span> </span><span id="local-6989586621679165842"><span class="annot"><span class="annottext">cs' :: Vector v (n + 1) a
</span><a href="#local-6989586621679165842"><span class="hs-identifier hs-var">cs'</span></a></span></span><span> </span><span id="local-6989586621679165841"><span class="annot"><span class="annottext">mds :: MVector (Mutable v) (n + 2) s a
</span><a href="#local-6989586621679165841"><span class="hs-identifier hs-var">mds</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-69"></span><span>      </span><span class="annot"><span class="annottext">ST s () -&gt; MaybeT (ST s) ()
forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
(MonadTrans t, Monad m) =&gt;
m a -&gt; t m a
</span><span class="hs-identifier hs-var">lift</span></span><span> </span><span class="annot"><span class="annottext">(ST s () -&gt; MaybeT (ST s) ()) -&gt; ST s () -&gt; MaybeT (ST s) ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">MVector (Mutable v) (1 + (1 + n)) (PrimState (ST s)) a
-&gt; (a -&gt; a) -&gt; Finite (1 + (1 + n)) -&gt; ST s ()
forall (v :: * -&gt; * -&gt; *) (n :: Nat) (m :: * -&gt; *) a.
(PrimMonad m, MVector v a) =&gt;
MVector v n (PrimState m) a -&gt; (a -&gt; a) -&gt; Finite n -&gt; m ()
</span><span class="hs-identifier hs-var">SMVG.modify</span></span><span> </span><span class="annot"><span class="annottext">MVector (Mutable v) (n + 2) s a
MVector (Mutable v) (1 + (1 + n)) (PrimState (ST s)) a
</span><a href="#local-6989586621679165841"><span class="hs-identifier hs-var">mds</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; a -&gt; a
forall a. Fractional a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">/</span></span><span> </span><span class="annot"><span class="annottext">Vector v (1 + (1 + n)) a -&gt; a
forall (v :: * -&gt; *) (n :: Nat) a.
Vector v a =&gt;
Vector v (1 + n) a -&gt; a
</span><span class="hs-identifier hs-var">SVG.head</span></span><span> </span><span class="annot"><span class="annottext">Vector v (n + 2) a
Vector v (1 + (1 + n)) a
</span><a href="#local-6989586621679165878"><span class="hs-identifier hs-var">bs</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Finite (1 + (1 + n))
forall a. Bounded a =&gt; a
</span><span class="hs-identifier hs-var">minBound</span></span><span>
</span><span id="line-70"></span><span>      </span><span class="annot"><span class="annottext">[(Finite (n + 1), Finite (1 + (1 + n)))]
-&gt; ((Finite (n + 1), Finite (1 + (1 + n))) -&gt; MaybeT (ST s) ())
-&gt; MaybeT (ST s) ()
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Foldable t, Applicative f) =&gt;
t a -&gt; (a -&gt; f b) -&gt; f ()
</span><span class="hs-identifier hs-var">for_</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">KnownNat (n + 1) =&gt; [(Finite (n + 1), Finite ((n + 1) + 1))]
forall (n :: Nat). KnownNat n =&gt; [(Finite n, Finite (n + 1))]
</span><a href="Numeric.EMD.Internal.Tridiagonal.html#consecFinites"><span class="hs-identifier hs-var">consecFinites</span></a></span><span> </span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679165881"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">+</span></span><span> </span><span class="annot"><span class="hs-number">1</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(((Finite (n + 1), Finite (1 + (1 + n))) -&gt; MaybeT (ST s) ())
 -&gt; MaybeT (ST s) ())
-&gt; ((Finite (n + 1), Finite (1 + (1 + n))) -&gt; MaybeT (ST s) ())
-&gt; MaybeT (ST s) ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-special">(</span><span id="local-6989586621679165840"><span class="annot"><span class="annottext">i0 :: Finite (n + 1)
</span><a href="#local-6989586621679165840"><span class="hs-identifier hs-var">i0</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679165839"><span class="annot"><span class="annottext">i1 :: Finite (1 + (1 + n))
</span><a href="#local-6989586621679165839"><span class="hs-identifier hs-var">i1</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-71"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679165838"><span class="annot"><span class="annottext">c0 :: a
</span><a href="#local-6989586621679165838"><span class="hs-identifier hs-var hs-var">c0</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Vector v (n + 1) a
</span><a href="#local-6989586621679165842"><span class="hs-identifier hs-var">cs'</span></a></span><span> </span><span class="annot"><span class="annottext">Vector v (n + 1) a -&gt; Finite (n + 1) -&gt; a
forall (v :: * -&gt; *) (n :: Nat) a.
Vector v a =&gt;
Vector v n a -&gt; Finite n -&gt; a
</span><span class="hs-operator hs-var">`SVG.index`</span></span><span> </span><span class="annot"><span class="annottext">Finite (n + 1)
</span><a href="#local-6989586621679165840"><span class="hs-identifier hs-var">i0</span></a></span><span>
</span><span id="line-72"></span><span>        </span><span id="local-6989586621679165837"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679165837"><span class="hs-identifier hs-var">d0</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">ST s a -&gt; MaybeT (ST s) a
forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
(MonadTrans t, Monad m) =&gt;
m a -&gt; t m a
</span><span class="hs-identifier hs-var">lift</span></span><span> </span><span class="annot"><span class="annottext">(ST s a -&gt; MaybeT (ST s) a) -&gt; ST s a -&gt; MaybeT (ST s) a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">MVector (Mutable v) (1 + (1 + n)) (PrimState (ST s)) a
-&gt; Finite (1 + (1 + n)) -&gt; ST s a
forall (v :: * -&gt; * -&gt; *) (n :: Nat) (m :: * -&gt; *) a.
(PrimMonad m, MVector v a) =&gt;
MVector v n (PrimState m) a -&gt; Finite n -&gt; m a
</span><span class="hs-identifier hs-var">SMVG.read</span></span><span> </span><span class="annot"><span class="annottext">MVector (Mutable v) (n + 2) s a
MVector (Mutable v) (1 + (1 + n)) (PrimState (ST s)) a
</span><a href="#local-6989586621679165841"><span class="hs-identifier hs-var">mds</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Finite (n + 1) -&gt; Finite ((n + 1) + 1)
forall (n :: Nat). Finite n -&gt; Finite (n + 1)
</span><span class="hs-identifier hs-var">weaken</span></span><span> </span><span class="annot"><span class="annottext">Finite (n + 1)
</span><a href="#local-6989586621679165840"><span class="hs-identifier hs-var">i0</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-73"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679165836"><span class="annot"><span class="annottext">sbr :: a
</span><a href="#local-6989586621679165836"><span class="hs-identifier hs-var hs-var">sbr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Vector v (n + 1) a
</span><a href="#local-6989586621679165879"><span class="hs-keyword hs-var">as</span></a></span><span> </span><span class="annot"><span class="annottext">Vector v (n + 1) a -&gt; Finite (n + 1) -&gt; a
forall (v :: * -&gt; *) (n :: Nat) a.
Vector v a =&gt;
Vector v n a -&gt; Finite n -&gt; a
</span><span class="hs-operator hs-var">`SVG.index`</span></span><span> </span><span class="annot"><span class="annottext">Finite (n + 1)
</span><a href="#local-6989586621679165840"><span class="hs-identifier hs-var">i0</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; a -&gt; a
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">*</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679165837"><span class="hs-identifier hs-var">d0</span></a></span><span>
</span><span id="line-74"></span><span>            </span><span id="local-6989586621679165835"><span class="annot"><span class="annottext">dvr :: a
</span><a href="#local-6989586621679165835"><span class="hs-identifier hs-var hs-var">dvr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Vector v (n + 2) a
Vector v (1 + (1 + n)) a
</span><a href="#local-6989586621679165878"><span class="hs-identifier hs-var">bs</span></a></span><span> </span><span class="annot"><span class="annottext">Vector v (1 + (1 + n)) a -&gt; Finite (1 + (1 + n)) -&gt; a
forall (v :: * -&gt; *) (n :: Nat) a.
Vector v a =&gt;
Vector v n a -&gt; Finite n -&gt; a
</span><span class="hs-operator hs-var">`SVG.index`</span></span><span> </span><span class="annot"><span class="annottext">Finite (1 + (1 + n))
</span><a href="#local-6989586621679165839"><span class="hs-identifier hs-var">i1</span></a></span><span>
</span><span id="line-75"></span><span>                </span><span class="annot"><span class="annottext">a -&gt; a -&gt; a
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">Vector v (n + 1) a
</span><a href="#local-6989586621679165879"><span class="hs-keyword hs-var">as</span></a></span><span> </span><span class="annot"><span class="annottext">Vector v (n + 1) a -&gt; Finite (n + 1) -&gt; a
forall (v :: * -&gt; *) (n :: Nat) a.
Vector v a =&gt;
Vector v n a -&gt; Finite n -&gt; a
</span><span class="hs-operator hs-var">`SVG.index`</span></span><span> </span><span class="annot"><span class="annottext">Finite (n + 1)
</span><a href="#local-6989586621679165840"><span class="hs-identifier hs-var">i0</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; a -&gt; a
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">*</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679165838"><span class="hs-identifier hs-var">c0</span></a></span><span>
</span><span id="line-76"></span><span>        </span><span class="annot"><span class="annottext">Bool -&gt; MaybeT (ST s) ()
forall (f :: * -&gt; *). Alternative f =&gt; Bool -&gt; f ()
</span><span class="hs-identifier hs-var">guard</span></span><span> </span><span class="annot"><span class="annottext">(Bool -&gt; MaybeT (ST s) ()) -&gt; Bool -&gt; MaybeT (ST s) ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679165835"><span class="hs-identifier hs-var">dvr</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; a -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">/=</span></span><span> </span><span class="annot"><span class="hs-number">0</span></span><span>
</span><span id="line-77"></span><span>        </span><span class="annot"><span class="annottext">ST s () -&gt; MaybeT (ST s) ()
forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
(MonadTrans t, Monad m) =&gt;
m a -&gt; t m a
</span><span class="hs-identifier hs-var">lift</span></span><span> </span><span class="annot"><span class="annottext">(ST s () -&gt; MaybeT (ST s) ()) -&gt; ST s () -&gt; MaybeT (ST s) ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">MVector (Mutable v) (1 + (1 + n)) (PrimState (ST s)) a
-&gt; (a -&gt; a) -&gt; Finite (1 + (1 + n)) -&gt; ST s ()
forall (v :: * -&gt; * -&gt; *) (n :: Nat) (m :: * -&gt; *) a.
(PrimMonad m, MVector v a) =&gt;
MVector v n (PrimState m) a -&gt; (a -&gt; a) -&gt; Finite n -&gt; m ()
</span><span class="hs-identifier hs-var">SMVG.modify</span></span><span> </span><span class="annot"><span class="annottext">MVector (Mutable v) (n + 2) s a
MVector (Mutable v) (1 + (1 + n)) (PrimState (ST s)) a
</span><a href="#local-6989586621679165841"><span class="hs-identifier hs-var">mds</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; a -&gt; a
forall a. Fractional a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">/</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679165835"><span class="hs-identifier hs-var">dvr</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(a -&gt; a) -&gt; (a -&gt; a) -&gt; a -&gt; a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; a -&gt; a
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-identifier hs-var">subtract</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679165836"><span class="hs-identifier hs-var">sbr</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Finite (1 + (1 + n))
</span><a href="#local-6989586621679165839"><span class="hs-identifier hs-var">i1</span></a></span><span>
</span><span id="line-78"></span><span>
</span><span id="line-79"></span><span id="local-6989586621679165914"><span class="annot"><a href="Numeric.EMD.Internal.Tridiagonal.html#consecFinites"><span class="hs-identifier hs-type">consecFinites</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">KnownNat</span></span><span> </span><span class="annot"><a href="#local-6989586621679165914"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Finite</span></span><span> </span><span class="annot"><a href="#local-6989586621679165914"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Finite</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679165914"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">+</span></span><span> </span><span class="annot"><span class="hs-number">1</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">]</span></span><span>
</span><span id="line-80"></span><span id="consecFinites"><span class="annot"><span class="annottext">consecFinites :: [(Finite n, Finite (n + 1))]
</span><a href="Numeric.EMD.Internal.Tridiagonal.html#consecFinites"><span class="hs-identifier hs-var hs-var">consecFinites</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Finite n] -&gt; [Finite (n + 1)] -&gt; [(Finite n, Finite (n + 1))]
forall a b. [a] -&gt; [b] -&gt; [(a, b)]
</span><span class="hs-identifier hs-var">zip</span></span><span> </span><span class="annot"><span class="annottext">[Finite n]
forall (n :: Nat). KnownNat n =&gt; [Finite n]
</span><span class="hs-identifier hs-var">finites</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Finite (n + 1)] -&gt; [Finite (n + 1)]
forall a. [a] -&gt; [a]
</span><span class="hs-identifier hs-var">tail</span></span><span> </span><span class="annot"><span class="annottext">[Finite (n + 1)]
forall (n :: Nat). KnownNat n =&gt; [Finite n]
</span><span class="hs-identifier hs-var">finites</span></span><span class="hs-special">)</span><span>
</span><span id="line-81"></span></pre></body></html>