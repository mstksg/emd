-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Hilbert-Huang Transform/Empirical Mode Decomposition
--   
--   Please see the README on GitHub at
--   <a>https://github.com/mstksg/emd#readme</a>
@package emd
@version 0.1.0.0

module Numeric.EMD

-- | EMD decomposition (Hilbert-Huang Transform) of a given time series
--   with a given sifting stop condition.
emd :: (Vector v a, KnownNat n, Fractional a, Ord a) => EMDOpts a -> Vector v (n + 2) a -> EMD v (n + 2) a

-- | <a>emd</a>, but tracing results to stdout as IMFs are found. Useful
--   for debugging to see how long each step is taking.
emdTrace :: (Vector v a, KnownNat n, Fractional a, Ord a, MonadIO m) => EMDOpts a -> Vector v (n + 2) a -> m (EMD v (n + 2) a)

-- | <a>emd</a> with a callback for each found IMF.
emd' :: (Vector v a, KnownNat n, Fractional a, Ord a, Applicative m) => (SiftResult v (n + 2) a -> m r) -> EMDOpts a -> Vector v (n + 2) a -> m (EMD v (n + 2) a)

-- | An <tt><a>EMD</a> v n a</tt> is a Hilbert-Huang transform of a time
--   series with <tt>n</tt> items of type <tt>a</tt> stored in a vector
--   <tt>v</tt>.
data EMD v n a
EMD :: ![Vector v n a] -> !(Vector v n a) -> EMD v n a
[emdIMFs] :: EMD v n a -> ![Vector v n a]
[emdResidual] :: EMD v n a -> !(Vector v n a)

-- | Options for EMD composition.
data EMDOpts a
EO :: SiftCondition a -> SplineEnd -> Bool -> EMDOpts a

-- | stop condition for sifting
[eoSiftCondition] :: EMDOpts a -> SiftCondition a

-- | end conditions for envelope splines
[eoSplineEnd] :: EMDOpts a -> SplineEnd

-- | if <a>True</a>, use time series endpoints as part of min and max
--   envelopes
[eoClampEnvelope] :: EMDOpts a -> Bool

-- | Default <a>EMDOpts</a>
defaultEO :: Fractional a => EMDOpts a

-- | Stop conditions for sifting process
data SiftCondition a

-- | Stop using standard <a>SD</a> method
SCStdDev :: a -> SiftCondition a

-- | Stop after a fixed number of iterations
SCTimes :: Int -> SiftCondition a

-- | one or the other
SCOr :: (SiftCondition a) -> (SiftCondition a) -> SiftCondition a

-- | both conditions met
SCAnd :: (SiftCondition a) -> (SiftCondition a) -> SiftCondition a

-- | Default <a>SiftCondition</a>
defaultSC :: Fractional a => SiftCondition a

-- | Iterated sifting process.
sift :: (Vector v a, KnownNat n, Fractional a, Ord a) => EMDOpts a -> Vector v (n + 2) a -> SiftResult v (n + 2) a

-- | Returns cubic splines of local minimums and maximums. Returns
--   <a>Nothing</a> if there are not enough local minimum or maximums to
--   create the splines.
envelopes :: (Vector v a, KnownNat n, Fractional a, Ord a) => SplineEnd -> Bool -> Vector v (n + 2) a -> Maybe (Vector v (n + 2) a, Vector v (n + 2) a)
instance GHC.Show.Show (v a) => GHC.Show.Show (Numeric.EMD.EMD v n a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Numeric.EMD.EMDOpts a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Numeric.EMD.EMDOpts a)
instance GHC.Show.Show a => GHC.Show.Show (Numeric.EMD.EMDOpts a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Numeric.EMD.SiftCondition a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Numeric.EMD.SiftCondition a)
instance GHC.Show.Show a => GHC.Show.Show (Numeric.EMD.SiftCondition a)
