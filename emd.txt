-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Empirical Mode Decomposition and Hilbert-Huang Transform
--   
--   Empirical Mode decomposition and Hilbert-Huang Transform in pure
--   Haskell.
@package emd
@version 0.1.5.1


-- | Internal splining functionality exported for testing purposes only.
--   This will likely go away in future versions, so please do not depend
--   on this!
module Numeric.EMD.Internal.Spline

-- | 1D Cubic spline
data Spline a

-- | End condition for spline
data SplineEnd a

-- | "Not-a-knot" condition: third derivatives are continuous at endpoints.
--   Default for matlab spline.
SENotAKnot :: SplineEnd a

-- | "Natural" condition: curve becomes a straight line at endpoints.
SENatural :: SplineEnd a

-- | "Clamped" condition: Slope of curves at endpoints are explicitly
--   given.
SEClamped :: a -> a -> SplineEnd a

-- | Build a cubic spline based on control points using given end
--   conditions (not-a-knot, or natural)
--   
--   <a>https://en.wikipedia.org/wiki/Spline_interpolation</a>
makeSpline :: forall a. (Ord a, Fractional a) => SplineEnd a -> Map a a -> Maybe (Spline a)

-- | Sample a spline at a given point.
sampleSpline :: (Fractional a, Ord a) => Spline a -> a -> a
instance GHC.Show.Show a => GHC.Show.Show (Numeric.EMD.Internal.Spline.SplineCoef a)
instance GHC.Generics.Generic (Numeric.EMD.Internal.Spline.SplineEnd a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Numeric.EMD.Internal.Spline.SplineEnd a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Numeric.EMD.Internal.Spline.SplineEnd a)
instance GHC.Show.Show a => GHC.Show.Show (Numeric.EMD.Internal.Spline.SplineEnd a)
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (Numeric.EMD.Internal.Spline.SplineEnd a)


-- | Empirical Mode Decomposition in pure Haskell.
--   
--   Main interface is <a>emd</a>, with <a>defaultEO</a>. A tracing version
--   that outputs a log to stdout is also available, as <a>emdTrace</a>.
--   This can be used to help track down a specific IMF that might be
--   taking more time than desired.
--   
--   This package uses "sized vectors" as its main interface, to ensure:
--   
--   <ol>
--   <li>The resulting <a>EMD</a> contains IMFs that are all the same
--   length as the input vector</li>
--   <li>We provide a vector of size of at least one.</li>
--   </ol>
--   
--   There are many functions to convert unsized vectors to sized vectors
--   in <a>Data.Vector.Sized</a> and associated modules, including
--   <tt>toSized</tt> (for when you know the size at compile-time) and
--   <tt>withSized</tt> (for when you don't).
module Numeric.EMD

-- | EMD decomposition of a given time series with a given sifting stop
--   condition.
--   
--   Takes a sized vector to ensure that:
--   
--   <ol>
--   <li>The resulting <a>EMD</a> contains IMFs that are all the same
--   length as the input vector</li>
--   <li>We provide a vector of size of at least one.</li>
--   </ol>
emd :: (Vector v a, KnownNat n, Fractional a, Ord a) => EMDOpts a -> Vector v (n + 1) a -> EMD v (n + 1) a

-- | <a>emd</a>, but tracing results to stdout as IMFs are found. Useful
--   for debugging to see how long each step is taking.
emdTrace :: (Vector v a, KnownNat n, Fractional a, Ord a, MonadIO m) => EMDOpts a -> Vector v (n + 1) a -> m (EMD v (n + 1) a)

-- | <a>emd</a> with a callback for each found IMF.
emd' :: (Vector v a, KnownNat n, Fractional a, Ord a, Applicative m) => (SiftResult v (n + 1) a -> m r) -> EMDOpts a -> Vector v (n + 1) a -> m (EMD v (n + 1) a)

-- | Collapse an <a>EMD</a> back into its original time series. Should be a
--   left-inverse to <a>emd</a>: using <a>iemd</a> on the result of
--   <a>emd</a> should give back the original vector.
iemd :: (Vector v a, Num a) => EMD v n a -> Vector v n a

-- | An <tt><a>EMD</a> v n a</tt> is an Empirical Mode Decomposition of a
--   time series with <tt>n</tt> items of type <tt>a</tt> stored in a
--   vector <tt>v</tt>.
--   
--   The component-wise sum of <a>emdIMFs</a> and <a>emdResidual</a> should
--   yield exactly the original series (see <a>iemd</a>).
data EMD v n a
EMD :: ![Vector v n a] -> !Vector v n a -> EMD v n a
[emdIMFs] :: EMD v n a -> ![Vector v n a]
[emdResidual] :: EMD v n a -> !Vector v n a

-- | Options for EMD composition.
data EMDOpts a
EO :: SiftCondition a -> SplineEnd a -> Maybe BoundaryHandler -> EMDOpts a

-- | stop condition for sifting
[eoSiftCondition] :: EMDOpts a -> SiftCondition a

-- | end conditions for envelope splines
[eoSplineEnd] :: EMDOpts a -> SplineEnd a

-- | process for handling boundary
[eoBoundaryHandler] :: EMDOpts a -> Maybe BoundaryHandler

-- | Default <a>EMDOpts</a>
defaultEO :: Fractional a => EMDOpts a
data BoundaryHandler

-- | Clamp envelope at end points (Matlab implementation)
BHClamp :: BoundaryHandler

-- | Extend boundaries symmetrically
BHSymmetric :: BoundaryHandler

-- | Stop conditions for sifting process
--   
--   Data type is lazy in its fields, so this infinite data type:
--   
--   <pre>
--   nTimes n = SCTimes n <a>SCOr</a> nTimes (n + 1)
--   </pre>
--   
--   will be treated identically as:
--   
--   <pre>
--   nTimes = SCTimes
--   </pre>
data SiftCondition a

-- | Stop using standard SD method
SCStdDev :: !a -> SiftCondition a

-- | Stop after a fixed number of sifting iterations
SCTimes :: !Int -> SiftCondition a

-- | One or the other
SCOr :: SiftCondition a -> SiftCondition a -> SiftCondition a

-- | Stop when both conditions are met
SCAnd :: SiftCondition a -> SiftCondition a -> SiftCondition a

-- | Default <a>SiftCondition</a>
defaultSC :: Fractional a => SiftCondition a

-- | End condition for spline
data SplineEnd a

-- | "Not-a-knot" condition: third derivatives are continuous at endpoints.
--   Default for matlab spline.
SENotAKnot :: SplineEnd a

-- | "Natural" condition: curve becomes a straight line at endpoints.
SENatural :: SplineEnd a

-- | "Clamped" condition: Slope of curves at endpoints are explicitly
--   given.
SEClamped :: a -> a -> SplineEnd a

-- | Iterated sifting process, used to produce either an IMF or a residual.
sift :: (Vector v a, KnownNat n, Fractional a, Ord a) => EMDOpts a -> Vector v (n + 1) a -> SiftResult v (n + 1) a

-- | The result of a sifting operation. Each sift either yields a residual,
--   or a new IMF.
data SiftResult v n a
SRResidual :: !Vector v n a -> SiftResult v n a

-- | number of sifting iterations
SRIMF :: !Vector v n a -> !Int -> SiftResult v n a

-- | Returns cubic splines of local minimums and maximums. Returns
--   <a>Nothing</a> if there are not enough local minimum or maximums to
--   create the splines.
envelopes :: (Vector v a, KnownNat n, Fractional a, Ord a) => SplineEnd a -> Maybe BoundaryHandler -> Vector v (n + 1) a -> Maybe (Vector v (n + 1) a, Vector v (n + 1) a)
instance GHC.Classes.Ord (v a) => GHC.Classes.Ord (Numeric.EMD.EMD v n a)
instance GHC.Classes.Eq (v a) => GHC.Classes.Eq (Numeric.EMD.EMD v n a)
instance GHC.Generics.Generic (Numeric.EMD.EMD v n a)
instance GHC.Show.Show (v a) => GHC.Show.Show (Numeric.EMD.EMD v n a)
instance GHC.Generics.Generic (Numeric.EMD.EMDOpts a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Numeric.EMD.EMDOpts a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Numeric.EMD.EMDOpts a)
instance GHC.Show.Show a => GHC.Show.Show (Numeric.EMD.EMDOpts a)
instance GHC.Generics.Generic (Numeric.EMD.SiftCondition a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Numeric.EMD.SiftCondition a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Numeric.EMD.SiftCondition a)
instance GHC.Show.Show a => GHC.Show.Show (Numeric.EMD.SiftCondition a)
instance GHC.Generics.Generic Numeric.EMD.BoundaryHandler
instance GHC.Classes.Ord Numeric.EMD.BoundaryHandler
instance GHC.Classes.Eq Numeric.EMD.BoundaryHandler
instance GHC.Show.Show Numeric.EMD.BoundaryHandler
instance Control.DeepSeq.NFData (v a) => Control.DeepSeq.NFData (Numeric.EMD.EMD v n a)
instance (Data.Vector.Generic.Base.Vector v a, GHC.TypeNats.KnownNat n, Data.Binary.Class.Binary (v a)) => Data.Binary.Class.Binary (Numeric.EMD.EMD v n a)
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (Numeric.EMD.EMDOpts a)
instance GHC.Real.Fractional a => Data.Default.Class.Default (Numeric.EMD.EMDOpts a)
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (Numeric.EMD.SiftCondition a)
instance GHC.Real.Fractional a => Data.Default.Class.Default (Numeric.EMD.SiftCondition a)
instance Data.Binary.Class.Binary Numeric.EMD.BoundaryHandler


-- | Hilbert-Huang transform in pure Haskell.
--   
--   The main data type is <a>HHT</a>, which can be generated using
--   <a>hht</a> or <a>hhtEmd</a>. See <a>Numeric.EMD</a> for information on
--   why this module uses "sized vectors", and how to convert unsized
--   vectors to sized vectors.
--   
--   Note that the Hilbert Transform implementation in this module is
--   slightly naive and is essentially O(n^2) on the length of the vector.
--   However, computation time for the full Hilbert-Huang Transform is
--   typically dominated by Empirical Mode Docomposition, which is
--   approximately O(n).
module Numeric.HHT

-- | A Hilbert-Huang Transform. An <tt><a>HHT</a> v n a</tt> is a
--   Hilbert-Huang transform of an <tt>n</tt>-item time series of items of
--   type <tt>a</tt> represented using vector <tt>v</tt>.
--   
--   Create using <a>hht</a> or <a>hhtEmd</a>.
newtype HHT v n a
HHT :: [HHTLine v n a] -> HHT v n a
[hhtLines] :: HHT v n a -> [HHTLine v n a]

-- | A Hilbert Trasnform of a given IMF, given as a "skeleton line".
data HHTLine v n a
HHTLine :: !Vector v n a -> !Vector v n a -> HHTLine v n a

-- | IMF HHT Magnitude as a time series
[hlMags] :: HHTLine v n a -> !Vector v n a

-- | IMF HHT instantaneous frequency as a time series (between 0 and 1)
[hlFreqs] :: HHTLine v n a -> !Vector v n a

-- | Compute the Hilbert-Huang transform from a given Empirical Mode
--   Decomposition.
hhtEmd :: forall v n a. (Vector v a, KnownNat n, RealFloat a) => EMD v (n + 1) a -> HHT v n a

-- | Directly compute the Hilbert-Huang transform of a given time series.
--   Essentially is a composition of <a>hhtEmd</a> and <a>emd</a>. See
--   <a>hhtEmd</a> for a more flexible version.
hht :: forall v n a. (Vector v a, KnownNat n, RealFloat a) => EMDOpts a -> Vector v (n + 1) a -> HHT v n a

-- | Compute the full Hilbert-Huang Transform spectrum. At each timestep is
--   a sparse map of frequency components and their respective magnitudes.
--   Frequencies not in the map are considered to be zero.
--   
--   Takes a "binning" function to allow you to specify how specific you
--   want your frequencies to be.
--   
--   See <tt>hhtSparseSpetrum</tt> for a sparser version, and
--   <a>hhtDenseSpectrum</a> for a denser version.
hhtSpectrum :: forall v n a k. (Vector v a, KnownNat n, Ord k, Num a) => (a -> k) -> HHT v n a -> Vector n (Map k a)

-- | A sparser vesion of <a>hhtSpectrum</a>. Compute the full Hilbert-Huang
--   Transform spectrum. Returns a <i>sparse</i> matrix representing the
--   power at each time step (the <tt><a>Finite</a> n</tt>) and frequency
--   (the <tt>k</tt>).
--   
--   Takes a "binning" function to allow you to specify how specific you
--   want your frequencies to be.
hhtSparseSpectrum :: forall v n a k. (Vector v a, KnownNat n, Ord k, Num a) => (a -> k) -> HHT v n a -> Map (Finite n, k) a

-- | A denser version of <a>hhtSpectrum</a>. Compute the full Hilbert-Huang
--   Transform spectrum, returning a dense matrix (as a vector of vectors)
--   representing the power at each time step and each frequency.
--   
--   Takes a "binning" function that maps a frequency to one of <tt>m</tt>
--   discrete slots, for accumulation in the dense matrix.
hhtDenseSpectrum :: forall v n m a. (Vector v a, KnownNat n, KnownNat m, Num a) => (a -> Finite m) -> HHT v n a -> Vector n (Vector m a)

-- | Compute the marginal spectrum given a Hilbert-Huang Transform. It is
--   similar to a Fourier Transform; it provides the "total power" over the
--   entire time series for each frequency component.
--   
--   A binning function is accepted to allow you to specify how specific
--   you want your frequencies to be.
marginal :: forall v n a k. (Vector v a, KnownNat n, Ord k, Num a) => (a -> k) -> HHT v n a -> Map k a

-- | Compute the instantaneous energy of the time series at every step via
--   the Hilbert-Huang Transform.
instantaneousEnergy :: forall v n a. (Vector v a, KnownNat n, Num a) => HHT v n a -> Vector v n a

-- | Degree of stationarity, as a function of frequency.
degreeOfStationarity :: forall v n a k. (Vector v a, KnownNat n, Ord k, Fractional a) => (a -> k) -> HHT v n a -> Map k a

-- | Returns the "expected value" of frequency at each time step,
--   calculated as a weighted average of all contributions at every
--   frequency at that time step.
expectedFreq :: forall v n a. (Vector v a, KnownNat n, Fractional a) => HHT v n a -> Vector v n a

-- | Returns the dominant frequency (frequency with largest magnitude
--   contribution) at each time step.
dominantFreq :: forall v n a. (Vector v a, KnownNat n, Ord a) => HHT v n a -> Vector v n a

-- | Options for EMD composition.
data EMDOpts a
EO :: SiftCondition a -> SplineEnd a -> Maybe BoundaryHandler -> EMDOpts a

-- | stop condition for sifting
[eoSiftCondition] :: EMDOpts a -> SiftCondition a

-- | end conditions for envelope splines
[eoSplineEnd] :: EMDOpts a -> SplineEnd a

-- | process for handling boundary
[eoBoundaryHandler] :: EMDOpts a -> Maybe BoundaryHandler

-- | Default <a>EMDOpts</a>
defaultEO :: Fractional a => EMDOpts a
data BoundaryHandler

-- | Clamp envelope at end points (Matlab implementation)
BHClamp :: BoundaryHandler

-- | Extend boundaries symmetrically
BHSymmetric :: BoundaryHandler

-- | Stop conditions for sifting process
--   
--   Data type is lazy in its fields, so this infinite data type:
--   
--   <pre>
--   nTimes n = SCTimes n <a>SCOr</a> nTimes (n + 1)
--   </pre>
--   
--   will be treated identically as:
--   
--   <pre>
--   nTimes = SCTimes
--   </pre>
data SiftCondition a

-- | Stop using standard SD method
SCStdDev :: !a -> SiftCondition a

-- | Stop after a fixed number of sifting iterations
SCTimes :: !Int -> SiftCondition a

-- | One or the other
SCOr :: SiftCondition a -> SiftCondition a -> SiftCondition a

-- | Stop when both conditions are met
SCAnd :: SiftCondition a -> SiftCondition a -> SiftCondition a

-- | Default <a>SiftCondition</a>
defaultSC :: Fractional a => SiftCondition a

-- | End condition for spline
data SplineEnd a

-- | "Not-a-knot" condition: third derivatives are continuous at endpoints.
--   Default for matlab spline.
SENotAKnot :: SplineEnd a

-- | "Natural" condition: curve becomes a straight line at endpoints.
SENatural :: SplineEnd a

-- | "Clamped" condition: Slope of curves at endpoints are explicitly
--   given.
SEClamped :: a -> a -> SplineEnd a

-- | Real part is original series and imaginary part is hilbert transformed
--   series. Creates a "helical" form of the original series that rotates
--   along the complex plane.
--   
--   Numerically assumes that the signal is zero everywhere outside of the
--   vector, instead of the periodic assumption taken by matlab's version.
hilbert :: forall v n a. (Vector v a, Vector v (Complex a), KnownNat n, Floating a) => Vector v n a -> Vector v n (Complex a)

-- | Hilbert transformed series. Essentially the same series, but
--   phase-shifted 90 degrees. Is so-named because it is the "imaginary
--   part" of the proper hilbert transform, <a>hilbert</a>.
--   
--   Numerically assumes that the signal is zero everywhere outside of the
--   vector, instead of the periodic assumption taken by matlab's version.
hilbertIm :: forall v n a. (Vector v a, KnownNat n, Floating a) => Vector v n a -> Vector v n a

-- | Given a time series, return a time series of the <i>magnitude</i> of
--   the hilbert transform and the <i>frequency</i> of the hilbert
--   transform, in units of revolutions per tick. Is only expected to taken
--   in proper/legal IMFs.
--   
--   The frequency will always be between 0 and 1, since we can't determine
--   anything faster given the discretization, and we exclude negative
--   values as physically unmeaningful for an IMF.
hilbertMagFreq :: forall v n a. (Vector v a, KnownNat n, RealFloat a) => Vector v (n + 1) a -> (Vector v (n + 1) a, Vector v n a)
instance GHC.Generics.Generic (Numeric.HHT.HHT v n a)
instance GHC.Classes.Ord (v a) => GHC.Classes.Ord (Numeric.HHT.HHT v n a)
instance GHC.Classes.Eq (v a) => GHC.Classes.Eq (Numeric.HHT.HHT v n a)
instance GHC.Show.Show (v a) => GHC.Show.Show (Numeric.HHT.HHT v n a)
instance GHC.Generics.Generic (Numeric.HHT.HHTLine v n a)
instance GHC.Classes.Ord (v a) => GHC.Classes.Ord (Numeric.HHT.HHTLine v n a)
instance GHC.Classes.Eq (v a) => GHC.Classes.Eq (Numeric.HHT.HHTLine v n a)
instance GHC.Show.Show (v a) => GHC.Show.Show (Numeric.HHT.HHTLine v n a)
instance (Data.Vector.Generic.Base.Vector v a, GHC.TypeNats.KnownNat n, Data.Binary.Class.Binary (v a)) => Data.Binary.Class.Binary (Numeric.HHT.HHT v n a)
instance Control.DeepSeq.NFData (v a) => Control.DeepSeq.NFData (Numeric.HHT.HHT v n a)
instance (Data.Vector.Generic.Base.Vector v a, GHC.TypeNats.KnownNat n, Data.Binary.Class.Binary (v a)) => Data.Binary.Class.Binary (Numeric.HHT.HHTLine v n a)
instance Control.DeepSeq.NFData (v a) => Control.DeepSeq.NFData (Numeric.HHT.HHTLine v n a)
