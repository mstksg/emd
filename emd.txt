-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Empirical Mode Decomposition and Hilbert-Huang Transform
--   
--   Empirical Mode decomposition and Hilbert-Huang Transform in pure
--   Haskell.
@package emd
@version 0.2.0.0


-- | Internal splining functionality exported for testing purposes only.
--   This will likely go away in future versions, so please do not depend
--   on this!
module Numeric.EMD.Internal.Spline

-- | 1D Cubic spline
data Spline a

-- | End condition for spline
data SplineEnd a

-- | "Not-a-knot" condition: third derivatives are continuous at endpoints.
--   Default for matlab spline.
SENotAKnot :: SplineEnd a

-- | "Natural" condition: curve becomes a straight line at endpoints.
SENatural :: SplineEnd a

-- | "Clamped" condition: Slope of curves at endpoints are explicitly
--   given.
SEClamped :: a -> a -> SplineEnd a

-- | Build a cubic spline based on control points using given end
--   conditions (not-a-knot, or natural)
--   
--   <a>https://en.wikipedia.org/wiki/Spline_interpolation</a>
makeSpline :: forall a. (Ord a, Fractional a) => SplineEnd a -> Map a a -> Maybe (Spline a)

-- | Sample a spline at a given point.
sampleSpline :: (Fractional a, Ord a) => Spline a -> a -> a
instance GHC.Show.Show a => GHC.Show.Show (Numeric.EMD.Internal.Spline.SplineCoef a)
instance GHC.Generics.Generic (Numeric.EMD.Internal.Spline.SplineEnd a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Numeric.EMD.Internal.Spline.SplineEnd a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Numeric.EMD.Internal.Spline.SplineEnd a)
instance GHC.Show.Show a => GHC.Show.Show (Numeric.EMD.Internal.Spline.SplineEnd a)
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (Numeric.EMD.Internal.Spline.SplineEnd a)


-- | Tools for creating your own custom sift stopping conditions.
module Numeric.EMD.Sift

-- | A sift stopping condition.
--   
--   It is a <a>Pipe</a> consumer that takes single sift step results
--   upstream and terminates with <tt>()</tt> as soon as it is satisfied
--   with the latest sift step.
--   
--   Use combinators like <tt>siftOr</tt> and <tt>siftAnd</tt> to combine
--   sifters, and the various sifters in <a>Numeric.EMD.Sift</a> to create
--   sifters from commonly established ones or new ones from scratch.
newtype Sifter v n a
Sifter :: Pipe (SingleSift v n a) Void Void (SM v n a) () -> Sifter v n a
[sPipe] :: Sifter v n a -> Pipe (SingleSift v n a) Void Void (SM v n a) ()

-- | The result of a sifting operation. Each sift either yields a residual,
--   or a new IMF.
data SiftResult v n a
SRResidual :: !Vector v n a -> SiftResult v n a

-- | number of sifting iterations
SRIMF :: !Vector v n a -> !Int -> SiftResult v n a

-- | Result of a single sift
data SingleSift v n a
SingleSift :: !Vector v n a -> !Vector v n a -> !Vector v n a -> SingleSift v n a
[ssResult] :: SingleSift v n a -> !Vector v n a
[ssMinEnv] :: SingleSift v n a -> !Vector v n a
[ssMaxEnv] :: SingleSift v n a -> !Vector v n a

-- | Monad where <a>Sifter</a> actions live. The reader parameter is the
--   "original vector".
type SM v n a = Reader (Vector v n a)

-- | Default <a>Sifter</a>
--   
--   <pre>
--   defaultSifter = <a>siftStdDev</a> 0.3 <a>siftOr</a> <a>siftTimes</a> 50
--   </pre>
--   
--   R package uses <tt><a>siftTimes</a> 20</tt>, Matlab uses no limit
defaultSifter :: (Vector v a, Fractional a, Ord a) => Sifter v n a

-- | Sift based on the "standard deviation test", outlined in original
--   paper.
siftStdDev :: forall v n a. (Vector v a, Fractional a, Ord a) => a -> Sifter v n a

-- | Create a sifter that stops after a given fixed number of sifts.
--   
--   Useful to use alongside <a>siftOr</a> to set an "upper limit" on the
--   number of sifts.
siftTimes :: Int -> Sifter v n a

-- | Cheng, Yu, Yang suggest pairing together an energy difference
--   threshold with a threshold for mean envelope RMS. This is a
--   convenience function to construct that pairing.
siftEnergyDiff :: (Vector v a, KnownNat n, Floating a, Ord a) => a -> a -> Sifter v n a

-- | Sift based on the "S-parameter" condition: Stop after a streak
--   <tt>n</tt> of almost-same numbers of zero crossings and turning
--   points.
siftSCond :: (Vector v a, KnownNat n, Fractional a, Ord a) => Int -> Sifter v (n + 1) a

-- | Combine two sifters in "and" fashion: The final sifter will complete
--   when <i>both</i> sifters complete.
siftAnd :: Sifter v n a -> Sifter v n a -> Sifter v n a
infixr 3 `siftAnd`

-- | Combine two sifters in "or" fashion: The final sifter will complete
--   when <i>either</i> sifter completes.
siftOr :: Sifter v n a -> Sifter v n a -> Sifter v n a
infixr 2 `siftOr`

-- | Project the root mean square of the mean of the maximum and minimum
--   envelopes.
envMean :: (Vector v a, KnownNat n, Floating a) => SingleSift v n a -> SM v n a a

-- | Project the <i>square root</i> of the "Energy difference".
energyDiff :: (Vector v a, Floating a) => SingleSift v n a -> SM v n a a

-- | Given a "projection function" (like <a>envMean</a> or
--   <a>energyDiff</a>), re-scale the result based on the RMS of the
--   original signal.
normalizeProj :: (Vector v a, KnownNat n, Floating a) => (SingleSift v n a -> SM v n a a) -> SingleSift v n a -> SM v n a a

-- | General class of "cauchy-like" sifters: Given a projection function
--   from a <a>SingleSift</a>, stop as soon as successive projections
--   become smaller than a given threshold, propertionally.
--   
--   Given &lt;math&gt;, stop when:
--   
--   &lt;math&gt;
siftCauchy :: (Fractional b, Ord b) => (SingleSift v n a -> b) -> b -> Sifter v n a

-- | Create a sifter that stops when some projection on two consecutive
--   <a>SingleSift</a>s is smaller than a given threshold.
siftPairs :: Ord b => (SingleSift v n a -> SingleSift v n a -> SM v n a b) -> b -> Sifter v n a

-- | Create a sifter that stops when some projection on <a>SingleSift</a>
--   is smaller than a given threshold.
siftProj :: Ord b => (SingleSift v n a -> SM v n a b) -> b -> Sifter v n a

-- | Create a sifter that stops based on some predicate on two consecutive
--   <a>SingleSift</a>s being <a>True</a>.
siftPairs_ :: (SingleSift v n a -> SingleSift v n a -> SM v n a Bool) -> Sifter v n a

-- | Create a sifter that stops based on some predicate on the initial
--   vector and <a>SingleSift</a> being <a>True</a>.
siftProj_ :: (SingleSift v n a -> SM v n a Bool) -> Sifter v n a

-- | Iterated sifting process, used to produce either an IMF or a residual.
sift :: forall v n a. (Vector v a, KnownNat n, Floating a, Ord a) => EMDOpts v (n + 1) a -> Vector v (n + 1) a -> SiftResult v (n + 1) a

-- | Returns cubic splines of local minimums and maximums. Returns
--   <a>Nothing</a> if there are not enough local minimum or maximums to
--   create the splines.
envelopes :: (Vector v a, KnownNat n, Fractional a, Ord a) => SplineEnd a -> Maybe BoundaryHandler -> Vector v (n + 1) a -> Maybe (Vector v (n + 1) a, Vector v (n + 1) a)

-- | Get the root mean square of a vector
rms :: (Vector v a, KnownNat n, Floating a) => Vector v n a -> a
instance (Data.Vector.Generic.Base.Vector v a, GHC.Real.Fractional a, GHC.Classes.Ord a) => Data.Default.Class.Default (Numeric.EMD.Internal.Sifter v n a)


-- | Empirical Mode Decomposition in pure Haskell.
--   
--   Main interface is <a>emd</a>, with <a>defaultEO</a>. A tracing version
--   that outputs a log to stdout is also available, as <a>emdTrace</a>.
--   This can be used to help track down a specific IMF that might be
--   taking more time than desired.
--   
--   This package uses "sized vectors" as its main interface, to ensure:
--   
--   <ol>
--   <li>The resulting <a>EMD</a> contains IMFs that are all the same
--   length as the input vector</li>
--   <li>We provide a vector of size of at least one.</li>
--   </ol>
--   
--   There are many functions to convert unsized vectors to sized vectors
--   in <a>Data.Vector.Sized</a> and associated modules, including
--   <a>toSized</a> (for when you know the size at compile-time) and
--   <a>withSized</a> (for when you don't).
module Numeric.EMD

-- | EMD decomposition of a given time series with a given sifting stop
--   condition.
--   
--   Takes a sized vector to ensure that:
--   
--   <ol>
--   <li>The resulting <a>EMD</a> contains IMFs that are all the same
--   length as the input vector</li>
--   <li>We provide a vector of size of at least one.</li>
--   </ol>
emd :: (Vector v a, KnownNat n, Floating a, Ord a) => EMDOpts v (n + 1) a -> Vector v (n + 1) a -> EMD v (n + 1) a

-- | <a>emd</a>, but tracing results to stdout as IMFs are found. Useful
--   for debugging to see how long each step is taking.
emdTrace :: (Vector v a, KnownNat n, Floating a, Ord a, MonadIO m) => EMDOpts v (n + 1) a -> Vector v (n + 1) a -> m (EMD v (n + 1) a)

-- | <a>emd</a> with a callback for each found IMF.
emd' :: (Vector v a, KnownNat n, Floating a, Ord a, Applicative m) => (SiftResult v (n + 1) a -> m r) -> EMDOpts v (n + 1) a -> Vector v (n + 1) a -> m (EMD v (n + 1) a)

-- | Collapse an <a>EMD</a> back into its original time series. Should be a
--   left-inverse to <a>emd</a>: using <a>iemd</a> on the result of
--   <a>emd</a> should give back the original vector.
iemd :: (Vector v a, Num a) => EMD v n a -> Vector v n a

-- | An <tt><a>EMD</a> v n a</tt> is an Empirical Mode Decomposition of a
--   time series with <tt>n</tt> items of type <tt>a</tt> stored in a
--   vector <tt>v</tt>.
--   
--   The component-wise sum of <a>emdIMFs</a> and <a>emdResidual</a> should
--   yield exactly the original series (see <a>iemd</a>).
data EMD v n a
EMD :: ![Vector v n a] -> !Vector v n a -> EMD v n a
[emdIMFs] :: EMD v n a -> ![Vector v n a]
[emdResidual] :: EMD v n a -> !Vector v n a

-- | Options for EMD composition.
data EMDOpts v n a
EO :: Sifter v n a -> SplineEnd a -> Maybe BoundaryHandler -> EMDOpts v n a

-- | stop condition for sifting
[eoSifter] :: EMDOpts v n a -> Sifter v n a

-- | end conditions for envelope splines
[eoSplineEnd] :: EMDOpts v n a -> SplineEnd a

-- | process for handling boundary
[eoBoundaryHandler] :: EMDOpts v n a -> Maybe BoundaryHandler

-- | Default <a>EMDOpts</a>
--   
--   Note: If you immediately use this and set <a>eoSifter</a>, then
--   <tt>v</tt> will be ambiguous. Explicitly set <tt>v</tt> with type
--   applications to appease GHC
--   
--   <pre>
--   <a>defaultEO</a> @(Data.Vector.Vector)
--      { eoSifter = scTimes 100
--      }
--   </pre>
defaultEO :: (Vector v a, Fractional a, Ord a) => EMDOpts v n a

-- | Boundary conditions for splines.
data BoundaryHandler

-- | Clamp envelope at end points (Matlab implementation)
BHClamp :: BoundaryHandler

-- | Extend boundaries symmetrically
BHSymmetric :: BoundaryHandler

-- | A sift stopping condition.
--   
--   It is a <a>Pipe</a> consumer that takes single sift step results
--   upstream and terminates with <tt>()</tt> as soon as it is satisfied
--   with the latest sift step.
--   
--   Use combinators like <tt>siftOr</tt> and <tt>siftAnd</tt> to combine
--   sifters, and the various sifters in <a>Numeric.EMD.Sift</a> to create
--   sifters from commonly established ones or new ones from scratch.
data Sifter v n a

-- | Default <a>Sifter</a>
--   
--   <pre>
--   defaultSifter = <a>siftStdDev</a> 0.3 <a>siftOr</a> <a>siftTimes</a> 50
--   </pre>
--   
--   R package uses <tt><a>siftTimes</a> 20</tt>, Matlab uses no limit
defaultSifter :: (Vector v a, Fractional a, Ord a) => Sifter v n a

-- | End condition for spline
data SplineEnd a

-- | "Not-a-knot" condition: third derivatives are continuous at endpoints.
--   Default for matlab spline.
SENotAKnot :: SplineEnd a

-- | "Natural" condition: curve becomes a straight line at endpoints.
SENatural :: SplineEnd a

-- | "Clamped" condition: Slope of curves at endpoints are explicitly
--   given.
SEClamped :: a -> a -> SplineEnd a

-- | Iterated sifting process, used to produce either an IMF or a residual.
sift :: forall v n a. (Vector v a, KnownNat n, Floating a, Ord a) => EMDOpts v (n + 1) a -> Vector v (n + 1) a -> SiftResult v (n + 1) a

-- | The result of a sifting operation. Each sift either yields a residual,
--   or a new IMF.
data SiftResult v n a
SRResidual :: !Vector v n a -> SiftResult v n a

-- | number of sifting iterations
SRIMF :: !Vector v n a -> !Int -> SiftResult v n a

-- | Returns cubic splines of local minimums and maximums. Returns
--   <a>Nothing</a> if there are not enough local minimum or maximums to
--   create the splines.
envelopes :: (Vector v a, KnownNat n, Fractional a, Ord a) => SplineEnd a -> Maybe BoundaryHandler -> Vector v (n + 1) a -> Maybe (Vector v (n + 1) a, Vector v (n + 1) a)
instance GHC.Classes.Ord (v a) => GHC.Classes.Ord (Numeric.EMD.EMD v n a)
instance GHC.Classes.Eq (v a) => GHC.Classes.Eq (Numeric.EMD.EMD v n a)
instance GHC.Generics.Generic (Numeric.EMD.EMD v n a)
instance GHC.Show.Show (v a) => GHC.Show.Show (Numeric.EMD.EMD v n a)
instance Control.DeepSeq.NFData (v a) => Control.DeepSeq.NFData (Numeric.EMD.EMD v n a)
instance (Data.Vector.Generic.Base.Vector v a, GHC.TypeNats.KnownNat n, Data.Binary.Class.Binary (v a)) => Data.Binary.Class.Binary (Numeric.EMD.EMD v n a)
instance (Data.Vector.Generic.Base.Vector v a, GHC.Real.Fractional a, GHC.Classes.Ord a) => Data.Default.Class.Default (Numeric.EMD.Internal.EMDOpts v n a)


-- | Hilbert-Huang transform in pure Haskell.
--   
--   The main data type is <a>HHT</a>, which can be generated using
--   <a>hht</a> or <a>hhtEmd</a>. See <a>Numeric.EMD</a> for information on
--   why this module uses "sized vectors", and how to convert unsized
--   vectors to sized vectors.
module Numeric.HHT

-- | A Hilbert-Huang Transform. An <tt><a>HHT</a> v n a</tt> is a
--   Hilbert-Huang transform of an <tt>n</tt>-item time series of items of
--   type <tt>a</tt> represented using vector <tt>v</tt>.
--   
--   Create using <a>hht</a> or <a>hhtEmd</a>.
data HHT v n a
HHT :: [HHTLine v n a] -> Vector v (n + 1) a -> HHT v n a

-- | Skeleton lines corresponding to each IMF
[hhtLines] :: HHT v n a -> [HHTLine v n a]

-- | Residual from EMD
[hhtResidual] :: HHT v n a -> Vector v (n + 1) a

-- | A Hilbert Trasnform of a given IMF, given as a "skeleton line".
data HHTLine v n a
HHTLine :: !Vector v (n + 1) a -> !Vector v n a -> !a -> HHTLine v n a

-- | IMF HHT Magnitude as a time series.
--   
--   It may be useful to "zip" this vector with <a>hlFreqs</a>. To do this,
--   use a function like <a>init</a> or <a>tail</a> to make these two
--   vectors contain the same length, or <a>weaken</a>/<a>shift</a> to make
--   indices in <a>hlFreqs</a> usable as indices in <a>hlMags</a>.
--   
--   Prior to v0.1.9.0, this was a length-n vector, just like
--   <a>hlFreqs</a>. To get the same behavior, use <a>init</a> on this new
--   field's value.
[hlMags] :: HHTLine v n a -> !Vector v (n + 1) a

-- | IMF HHT instantaneous frequency as a time series (between 0 and 1).
--   
--   In reality, these frequencies are the frequencies "in between" each
--   step in <a>hlMags</a>.
[hlFreqs] :: HHTLine v n a -> !Vector v n a

-- | Initial phase of skeleton line (between -pi and pi)
[hlInitPhase] :: HHTLine v n a -> !a

-- | Compute the Hilbert-Huang transform from a given Empirical Mode
--   Decomposition.
hhtEmd :: forall v n a. (Vector v a, Vector v (Complex a), KnownNat n, FFTWReal a) => EMD v (n + 1) a -> HHT v n a

-- | Directly compute the Hilbert-Huang transform of a given time series.
--   Essentially is a composition of <a>hhtEmd</a> and <a>emd</a>. See
--   <a>hhtEmd</a> for a more flexible version.
hht :: forall v n a. (Vector v a, Vector v (Complex a), KnownNat n, FFTWReal a) => EMDOpts v (n + 1) a -> Vector v (n + 1) a -> HHT v n a

-- | Invert a Hilbert-Huang transform back to an Empirical Mode
--   Decomposition
ihhtEmd :: (Vector v a, Floating a) => HHT v n a -> EMD v (n + 1) a

-- | Construct a time series correpsonding to its hilbert-huang transform.
ihht :: (Vector v a, Floating a) => HHT v n a -> Vector v (n + 1) a

-- | Compute the full Hilbert-Huang Transform spectrum. At each timestep is
--   a sparse map of frequency components and their respective magnitudes.
--   Frequencies not in the map are considered to be zero.
--   
--   Takes a "binning" function to allow you to specify how specific you
--   want your frequencies to be.
--   
--   See <a>hhtSparseSpectrum</a> for a sparser version, and
--   <a>hhtDenseSpectrum</a> for a denser version.
hhtSpectrum :: forall v n a k. (Vector v a, KnownNat n, Ord k, Num a) => (a -> k) -> HHT v n a -> Vector n (Map k a)

-- | A sparser vesion of <a>hhtSpectrum</a>. Compute the full Hilbert-Huang
--   Transform spectrum. Returns a <i>sparse</i> matrix representing the
--   power at each time step (the <tt><a>Finite</a> n</tt>) and frequency
--   (the <tt>k</tt>).
--   
--   Takes a "binning" function to allow you to specify how specific you
--   want your frequencies to be.
hhtSparseSpectrum :: forall v n a k. (Vector v a, KnownNat n, Ord k, Num a) => (a -> k) -> HHT v n a -> Map (Finite n, k) a

-- | A denser version of <a>hhtSpectrum</a>. Compute the full Hilbert-Huang
--   Transform spectrum, returning a dense matrix (as a vector of vectors)
--   representing the power at each time step and each frequency.
--   
--   Takes a "binning" function that maps a frequency to one of <tt>m</tt>
--   discrete slots, for accumulation in the dense matrix.
hhtDenseSpectrum :: forall v n m a. (Vector v a, KnownNat n, KnownNat m, Num a) => (a -> Finite m) -> HHT v n a -> Vector n (Vector m a)

-- | Compute the mean marginal spectrum given a Hilbert-Huang Transform. It
--   is similar to a Fourier Transform; it provides the "total power" over
--   the entire time series for each frequency component, averaged over the
--   length of the time series.
--   
--   A binning function is accepted to allow you to specify how specific
--   you want your frequencies to be.
meanMarginal :: forall v n a k. (Vector v a, KnownNat n, Ord k, Fractional a) => (a -> k) -> HHT v n a -> Map k a

-- | Compute the marginal spectrum given a Hilbert-Huang Transform. It
--   provides the "total power" over the entire time series for each
--   frequency component. See <a>meanMarginal</a> for a version that
--   averages over the length of the time series, making it more close in
--   nature to the purpose of a Fourier Transform.
--   
--   A binning function is accepted to allow you to specify how specific
--   you want your frequencies to be.
marginal :: forall v n a k. (Vector v a, KnownNat n, Ord k, Num a) => (a -> k) -> HHT v n a -> Map k a

-- | Compute the instantaneous energy of the time series at every step via
--   the Hilbert-Huang Transform.
instantaneousEnergy :: forall v n a. (Vector v a, KnownNat n, Num a) => HHT v n a -> Vector v n a

-- | Degree of stationarity, as a function of frequency.
degreeOfStationarity :: forall v n a k. (Vector v a, KnownNat n, Ord k, Fractional a, Eq a) => (a -> k) -> HHT v n a -> Map k a

-- | Returns the "expected value" of frequency at each time step,
--   calculated as a weighted average of all contributions at every
--   frequency at that time step.
expectedFreq :: forall v n a. (Vector v a, KnownNat n, Fractional a) => HHT v n a -> Vector v n a

-- | Returns the dominant frequency (frequency with largest magnitude
--   contribution) at each time step.
dominantFreq :: forall v n a. (Vector v a, KnownNat n, Ord a) => HHT v n a -> Vector v n a

-- | Fold and collapse a Hilbert-Huang transform along the frequency axis
--   at each step in time along some monoid.
foldFreq :: forall v u n a b c. (Vector v a, Vector u c, KnownNat n, Monoid b) => (a -> a -> b) -> (b -> c) -> HHT v n a -> Vector u n c

-- | Options for EMD composition.
data EMDOpts v n a
EO :: Sifter v n a -> SplineEnd a -> Maybe BoundaryHandler -> EMDOpts v n a

-- | stop condition for sifting
[eoSifter] :: EMDOpts v n a -> Sifter v n a

-- | end conditions for envelope splines
[eoSplineEnd] :: EMDOpts v n a -> SplineEnd a

-- | process for handling boundary
[eoBoundaryHandler] :: EMDOpts v n a -> Maybe BoundaryHandler

-- | Default <a>EMDOpts</a>
--   
--   Note: If you immediately use this and set <a>eoSifter</a>, then
--   <tt>v</tt> will be ambiguous. Explicitly set <tt>v</tt> with type
--   applications to appease GHC
--   
--   <pre>
--   <a>defaultEO</a> @(Data.Vector.Vector)
--      { eoSifter = scTimes 100
--      }
--   </pre>
defaultEO :: (Vector v a, Fractional a, Ord a) => EMDOpts v n a

-- | Boundary conditions for splines.
data BoundaryHandler

-- | Clamp envelope at end points (Matlab implementation)
BHClamp :: BoundaryHandler

-- | Extend boundaries symmetrically
BHSymmetric :: BoundaryHandler

-- | Default <a>Sifter</a>
--   
--   <pre>
--   defaultSifter = <a>siftStdDev</a> 0.3 <a>siftOr</a> <a>siftTimes</a> 50
--   </pre>
--   
--   R package uses <tt><a>siftTimes</a> 20</tt>, Matlab uses no limit
defaultSifter :: (Vector v a, Fractional a, Ord a) => Sifter v n a

-- | End condition for spline
data SplineEnd a

-- | "Not-a-knot" condition: third derivatives are continuous at endpoints.
--   Default for matlab spline.
SENotAKnot :: SplineEnd a

-- | "Natural" condition: curve becomes a straight line at endpoints.
SENatural :: SplineEnd a

-- | "Clamped" condition: Slope of curves at endpoints are explicitly
--   given.
SEClamped :: a -> a -> SplineEnd a

-- | Real part is original series and imaginary part is hilbert transformed
--   series. Creates a "helical" form of the original series that rotates
--   along the complex plane.
--   
--   Note that since <i>0.1.7.0</i>, this uses the same algorithm as the
--   matlab implementation
--   <a>https://www.mathworks.com/help/signal/ref/hilbert.html</a>
hilbert :: forall v n a. (Vector v a, Vector v (Complex a), KnownNat n, FFTWReal a) => Vector v n a -> Vector v n (Complex a)

-- | Hilbert transformed series. Essentially the same series, but
--   phase-shifted 90 degrees. Is so-named because it is the "imaginary
--   part" of the proper hilbert transform, <a>hilbert</a>.
--   
--   Note that since <i>0.1.7.0</i>, this uses the same algorithm as the
--   matlab implementation
--   <a>https://www.mathworks.com/help/signal/ref/hilbert.html</a>
hilbertIm :: forall v n a. (Vector v a, Vector v (Complex a), KnownNat n, FFTWReal a) => Vector v n a -> Vector v n a

-- | The polar form of <a>hilbert</a>: returns the magnitude and phase of
--   the discrete hilbert transform of a series.
--   
--   The computation of magnitude is unique, but computing phase gives us
--   some ambiguity. The interpretation of the hilbert transform for
--   instantaneous frequency is that the original series "spirals" around
--   the complex plane as time progresses, like a helix. So, we impose a
--   constraint on the phase to uniquely determine it: &lt;math&gt; is the
--   <i>minimal valid phase</i> such that &lt;math&gt;. This enforces the
--   phase to be monotonically increasing at the slowest possible
--   detectable rate.
hilbertPolar :: forall v n a. (Vector v a, Vector v (Complex a), KnownNat n, FFTWReal a) => Vector v (n + 1) a -> (Vector v (n + 1) a, Vector v (n + 1) a)

-- | Given a time series, return a time series of the <i>magnitude</i> of
--   the hilbert transform and the <i>frequency</i> of the hilbert
--   transform, in units of revolutions per tick. Is only expected to taken
--   in proper/legal IMFs.
--   
--   The frequency will always be between 0 and 1, since we can't determine
--   anything faster given the discretization, and we exclude negative
--   values as physically unmeaningful for an IMF.
hilbertMagFreq :: forall v n a. (Vector v a, Vector v (Complex a), KnownNat n, FFTWReal a) => Vector v (n + 1) a -> (Vector v (n + 1) a, (Vector v n a, a))
instance GHC.Generics.Generic (Numeric.HHT.HHT v n a)
instance (GHC.Classes.Ord a, GHC.Classes.Ord (v a)) => GHC.Classes.Ord (Numeric.HHT.HHT v n a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq (v a)) => GHC.Classes.Eq (Numeric.HHT.HHT v n a)
instance (GHC.Show.Show a, GHC.Show.Show (v a)) => GHC.Show.Show (Numeric.HHT.HHT v n a)
instance GHC.Generics.Generic (Numeric.HHT.HHTLine v n a)
instance (GHC.Classes.Ord a, GHC.Classes.Ord (v a)) => GHC.Classes.Ord (Numeric.HHT.HHTLine v n a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq (v a)) => GHC.Classes.Eq (Numeric.HHT.HHTLine v n a)
instance (GHC.Show.Show a, GHC.Show.Show (v a)) => GHC.Show.Show (Numeric.HHT.HHTLine v n a)
instance (GHC.Classes.Ord k, GHC.Num.Num a) => GHC.Base.Semigroup (Numeric.HHT.SumMap k a)
instance (GHC.Classes.Ord k, GHC.Num.Num a) => GHC.Base.Monoid (Numeric.HHT.SumMap k a)
instance (Data.Vector.Generic.Base.Vector v a, GHC.TypeNats.KnownNat n, Data.Binary.Class.Binary (v a), Data.Binary.Class.Binary a) => Data.Binary.Class.Binary (Numeric.HHT.HHT v n a)
instance (Control.DeepSeq.NFData (v a), Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (Numeric.HHT.HHT v n a)
instance (Data.Vector.Generic.Base.Vector v a, GHC.TypeNats.KnownNat n, Data.Binary.Class.Binary (v a), Data.Binary.Class.Binary a) => Data.Binary.Class.Binary (Numeric.HHT.HHTLine v n a)
instance (Control.DeepSeq.NFData (v a), Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (Numeric.HHT.HHTLine v n a)
